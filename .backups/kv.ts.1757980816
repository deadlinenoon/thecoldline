/* eslint-disable @typescript-eslint/no-explicit-any */
// Unified KV wrapper with type-stable helpers and back-compat exports.
export type KV = {
  // scalars
  get: (key: string) => Promise<string | number | null>;
  getNum: (key: string) => Promise<number>;
  setNX: (key: string, value: string, ttlSec?: number) => Promise<boolean>;
  del: (key: string) => Promise<number>;
  incr: (key: string, by?: number) => Promise<number>;
  incrBy: (key: string, by: number) => Promise<number>;
  // hashes
  hset: (key: string, obj: Record<string, string | number>) => Promise<number>;
  hgetall: (key: string) => Promise<Record<string, string>>;
  // lists
  lpush: (key: string, ...values: string[]) => Promise<number>;
  lrange: (key: string, start: number, stop: number) => Promise<string[]>;
  // sets
  sadd: (key: string, ...members: string[]) => Promise<number>;
  smembers: (key: string) => Promise<string[]>;
  srem: (key: string, ...members: string[]) => Promise<number>;
  // sorted sets
  zincrBy: (key: string, member: string, by?: number) => Promise<number>;
  zincr: (key: string, member: string, by?: number) => Promise<number>; // alias for back-compat
  ztop: (key: string, limit: number) => Promise<[string, number][]>;
};

const url = process.env.UPSTASH_REDIS_REST_URL;
const token = process.env.UPSTASH_REDIS_REST_TOKEN;

// Real client (lazy import so builds donâ€™t scream without envs)
async function real(): Promise<KV> {
  if (!url || !token) throw new Error("Upstash env missing");
  const { Redis } = await import("@upstash/redis");
  const redis = new Redis({ url, token });

  return {
    async get(key) {
      const v = await redis.get(key);
      return (v as any) ?? null;
    },
    async getNum(key) {
      const v = await redis.get<number>(key);
      return Number(v ?? 0);
    },
    async setNX(key, value, ttlSec) {
      const opts: any = ttlSec != null ? { nx: true, ex: ttlSec } : { nx: true };
      const res = await redis.set(key, value, opts);
      return res === "OK";
    },
    async del(key) { return await redis.del(key); },
    async incr(key, by = 1) { return await redis.incrby(key, by); },
    async incrBy(key, by) { return await redis.incrby(key, by); },

    async hset(key, obj) { return await redis.hset(key, obj as any); },
    async hgetall(key) {
      const o = await redis.hgetall<Record<string, string>>(key);
      return o ?? {};
    },

    async lpush(key, ...values) { return await redis.lpush(key, ...values); },
    async lrange(key, start, stop) {
      // Force array-of-strings; avoid bad generic inference.
      const out = await (redis as any).lrange(key, start, stop) as unknown;
      return Array.isArray(out) ? (out as any[]).map(String) : [];
    },

    async sadd(key, ...members) {
      // Help TS with spread tuple typing
      const tuple = members as unknown as [string, ...string[]] | [];
      return tuple.length ? await (redis as any).sadd(key, ...tuple) : 0;
    },
    async smembers(key) {
      const out = await (redis as any).smembers(key) as unknown;
      return Array.isArray(out) ? (out as any[]).map(String) : [];
    },
    async srem(key, ...members) {
      const tuple = members as unknown as [string, ...string[]] | [];
      return tuple.length ? await (redis as any).srem(key, ...tuple) : 0;
    },

    // Use zincrby (correct signature) for sorted set increments
    async zincrBy(key, member, by = 1) {
      const newScore = await (redis as any).zincrby(key, by, member);
      return Number(newScore ?? 0);
    },
    async zincr(key, member, by = 1) { return this.zincrBy(key, member, by); },

    async ztop(key, limit) {
      const arr = await redis.zrange<(string | number)[]>(key, -limit, -1, { rev: true, withScores: true });
      const out: [string, number][] = [];
      for (let i = 0; i < arr.length; i += 2) out.push([String(arr[i]), Number(arr[i + 1])]);
      return out;
    },
  };
}

// In-memory fallback (dev / missing envs)
function memory(): KV {
  const scalars = new Map<string, string>();
  const hashes = new Map<string, Map<string, string>>();
  const lists = new Map<string, string[]>();
  const sets = new Map<string, Set<string>>();
  const zsets = new Map<string, Map<string, number>>();

  const ztopLocal = (key: string, limit: number): [string, number][] =>
    [...(zsets.get(key) ?? new Map()).entries()].sort((a,b)=>b[1]-a[1]).slice(0, limit) as [string, number][];

  return {
    async get(k){ return scalars.has(k) ? (scalars.get(k) as any) : null; },
    async getNum(k){ return Number(scalars.get(k) ?? 0); },
    async setNX(k,v){ if (scalars.has(k)) return false; scalars.set(k, String(v)); return true; },
    async del(k){ return scalars.delete(k) ? 1 : 0; },
    async incr(k, by=1){ const n = Number(scalars.get(k) ?? 0) + by; scalars.set(k, String(n)); return n; },
    async incrBy(k, by){ const n = Number(scalars.get(k) ?? 0) + by; scalars.set(k, String(n)); return n; },

    async hset(k, obj){ const m = hashes.get(k) ?? new Map(); hashes.set(k, m); Object.entries(obj).forEach(([f,v])=>m.set(f, String(v))); return (hashes.get(k) ?? m).size; },
    async hgetall(k){ const m = hashes.get(k) ?? new Map(); return Object.fromEntries(m.entries()); },

    async lpush(k, ...values){ const a = lists.get(k) ?? []; lists.set(k, [...values, ...a]); return lists.get(k)!.length; },
    async lrange(k, s, t){ const a = lists.get(k) ?? []; const norm=(i:number)=>i<0?a.length+i:i; return a.slice(norm(s), t===-1?undefined:norm(t)+1); },

    async sadd(k, ...members){ const s = sets.get(k) ?? new Set(); sets.set(k, s); let add=0; for(const m of members){ if(!s.has(m)){ s.add(m); add++; }} return add; },
    async smembers(k){ const s = sets.get(k) ?? new Set(); return [...s.values()]; },
    async srem(k, ...members){ const s = sets.get(k) ?? new Set(); sets.set(k, s); let rem=0; for(const m of members){ if(s.delete(m)) rem++; } return rem; },

    async zincrBy(k, member, by=1){ const m=zsets.get(k) ?? new Map(); zsets.set(k, m); m.set(member,(m.get(member) ?? 0)+by); return m.get(member)!; },
    async zincr(k, member, by=1){ return this.zincrBy(k, member, by); },
    async ztop(k, limit){ return ztopLocal(k, limit); },
  };
}

// Entry point
export async function getKV(): Promise<KV> {
  try { return await real(); } catch { return memory(); }
}

// Back-compat helper exports (match existing imports across the repo)
export function kvAvailable(): boolean {
  return !!(process.env.UPSTASH_REDIS_REST_URL && process.env.UPSTASH_REDIS_REST_TOKEN);
}
export async function kvGet(key: string) { return (await getKV()).get(key); }
export async function kvSetNX(key: string, value: string, ttlSec?: number) { return (await getKV()).setNX(key, value, ttlSec); }
export async function kvDel(key: string) { return (await getKV()).del(key); }
export async function kvHSet(key: string, obj: Record<string, string | number>) { return (await getKV()).hset(key, obj); }
export async function kvHGetAll(key: string) { return (await getKV()).hgetall(key); }
export async function kvLPush(key: string, ...values: string[]) { return (await getKV()).lpush(key, ...values); }
export async function kvLRange(key: string, start: number, stop: number) { return (await getKV()).lrange(key, start, stop); }
export async function kvSAdd(key: string, ...members: string[]) { return (await getKV()).sadd(key, ...members); }
export async function kvSMembers(key: string) { return (await getKV()).smembers(key); }
export async function kvSRem(key: string, ...members: string[]) { return (await getKV()).srem(key, ...members); }
export async function kvIncr(key: string, by = 1) { return (await getKV()).incr(key, by); }
export async function kvIncrBy(key: string, by: number) { return (await getKV()).incrBy(key, by); }
export async function kvZIncrBy(key: string, member: string, by = 1) { return (await getKV()).zincrBy(key, member, by); }
export async function kvZIncr(key: string, member: string, by = 1) { return (await getKV()).zincr(key, member, by); }
